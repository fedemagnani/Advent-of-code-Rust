<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src\lib.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>lib.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../advent_of_code/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../advent_of_code/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../advent_of_code/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
</pre><pre class="rust"><code><span class="kw">use</span> <span class="ident">std::collections::HashSet</span>; 
<span class="kw">use</span> <span class="ident">std::collections::HashMap</span>;
<span class="kw">use</span> <span class="ident">std::fs</span>;

<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">day1</span>{
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">part1</span>(<span class="ident">_file_name</span>:<span class="kw-2">&amp;</span><span class="ident">str</span>, <span class="ident">_target</span>:<span class="kw-2">&amp;</span><span class="ident">i32</span>)-&gt;<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>,<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>{
        <span class="kw">let</span> <span class="ident">content</span>:<span class="ident">String</span> <span class="op">=</span> <span class="ident"><span class="kw">super</span>::fs::read_to_string</span>(<span class="ident">_file_name</span>).<span class="ident">unwrap</span>();

        <span class="kw">let</span> <span class="ident">v</span>:<span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">content</span>.<span class="ident">lines</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>()).<span class="ident">collect</span>();
        <span class="comment">// What we did:</span>
        <span class="comment">// we started from a String type -&gt; we created a Lines struct via string.lines(): this is very similiar to the Split struct</span>
        <span class="comment">// split implements the map method: we define in |x| the variable on which we shall iterate and we put the function right after it</span>
        <span class="comment">// since x is a &amp;str type, it implements the parse() method</span>
        <span class="comment">// since parse returns a Result type (indeed the &amp;str might not be parseable), we unwrap the result</span>
        <span class="comment">// now we have a Map struct of i32 values -&gt; in order to convert it to a Vec type we use .collect()</span>

        <span class="kw">let</span> <span class="ident">hash_set</span>:<span class="ident"><span class="kw">super</span>::HashSet</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span><span class="op">=</span><span class="ident">v</span>.<span class="ident">iter</span>().<span class="ident">cloned</span>().<span class="ident">collect</span>();
        <span class="comment">// What we did:</span>
        <span class="comment">// we started from a Vec&lt;i32&gt; type -&gt; we convert it into an Iter struct.</span>
        <span class="comment">// the iter contains references, in order to create an equivalent de-referenced array we need to use .cloned()</span>
        <span class="comment">// we apply .collect() in order to convert the Iter into an hashset</span>

        <span class="comment">// watch out in using .collect:</span>
        <span class="comment">// Map.collect() -&gt; Vec</span>
        <span class="comment">// Iter.collect() -&gt; HashSet</span>

        <span class="comment">// HashSet is useful thanks to methods such as .contains(), .intersection(), .union()</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">good_couple</span>:(<span class="ident">i32</span>,<span class="ident">i32</span>)<span class="op">=</span>(<span class="number">0</span>,<span class="number">0</span>);
        <span class="kw">for</span> <span class="ident">value</span> <span class="kw">in</span> <span class="ident">v</span>{
            <span class="kw">let</span> <span class="ident">complement</span> <span class="op">=</span> <span class="ident">_target</span><span class="op">-</span><span class="ident">value</span>; <span class="comment">//recall that value + complement = 2020</span>
            <span class="kw">if</span> <span class="ident">hash_set</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="ident">complement</span>){
                <span class="ident">good_couple</span>.<span class="number">0</span><span class="op">=</span><span class="ident">value</span>;
                <span class="ident">good_couple</span>.<span class="number">1</span><span class="op">=</span><span class="ident">complement</span>;
                <span class="kw">break</span>
            }
        }
        <span class="kw">if</span>  <span class="ident">good_couple</span> <span class="op">!</span><span class="op">=</span> (<span class="number">0</span>,<span class="number">0</span>) <span class="op">&amp;&amp;</span> <span class="kw-2">*</span><span class="ident">_target</span> <span class="op">!</span><span class="op">=</span> <span class="number">0</span>{
            <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">good_couple</span>.<span class="number">0</span><span class="kw-2">*</span><span class="ident">good_couple</span>.<span class="number">1</span>);
        }<span class="kw">else</span>{
            <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="string">&quot;There isn&#39;t any good couple :(&quot;</span>)
        }
        <span class="comment">// What we did:</span>
        <span class="comment">// we iterated over each element of the vector and we compute the complement: this is the other item we&#39;re looking for</span>
        <span class="comment">// thanks to the HashSet, we are able to identify whether the complement is present in list or not</span>
        <span class="comment">// if so, we compute the product between the two numbers</span>
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">part2</span>(<span class="ident">_file_name</span>:<span class="kw-2">&amp;</span><span class="ident">str</span>,<span class="ident">_target</span>:<span class="kw-2">&amp;</span><span class="ident">i32</span>)-&gt;<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>,<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>{
        <span class="kw">let</span> <span class="ident">content</span>:<span class="ident">String</span> <span class="op">=</span> <span class="ident"><span class="kw">super</span>::fs::read_to_string</span>(<span class="ident">_file_name</span>).<span class="ident">unwrap</span>();
        <span class="kw">let</span> <span class="ident">v</span>:<span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span><span class="op">=</span><span class="ident">content</span>.<span class="ident">lines</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span><span class="ident">x</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>()).<span class="ident">collect</span>();
        <span class="kw">let</span> <span class="ident">hash_set</span>:<span class="ident"><span class="kw">super</span>::HashSet</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span><span class="op">=</span><span class="ident">v</span>.<span class="ident">iter</span>().<span class="ident">cloned</span>().<span class="ident">collect</span>();
        <span class="comment">//recalll that now value + complement1 + complement2 = 2020</span>
        <span class="kw">for</span> <span class="ident">value</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">v</span>{
            <span class="kw">for</span> <span class="ident">possible_complement1</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">v</span>{
                <span class="kw">let</span> <span class="ident">complement2</span> <span class="op">=</span> <span class="ident">_target</span><span class="op">-</span>(<span class="ident">possible_complement1</span><span class="op">+</span><span class="ident">value</span>);
                <span class="kw">if</span> <span class="ident">hash_set</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="ident">complement2</span>){
                    <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">value</span> <span class="op">*</span> <span class="ident">possible_complement1</span> <span class="op">*</span> <span class="ident">complement2</span>);
                }
            }
        }
        <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="string">&quot;There isn&#39;t any good triplet :(&quot;</span>); <span class="comment">//we reach this part of code only if values are missing, otherwhise we exit inside the for loop</span>
    }
}

<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">day2</span>{
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">part1</span>(<span class="ident">file_name</span>:<span class="kw-2">&amp;</span><span class="ident">str</span>)-&gt;<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>,<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>{
        <span class="kw">let</span> <span class="ident">content</span> <span class="op">=</span> <span class="ident"><span class="kw">super</span>::fs::read_to_string</span>(<span class="ident">file_name</span>).<span class="ident">unwrap</span>();
        <span class="kw">let</span> <span class="ident">v</span>:<span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">content</span>.<span class="ident">lines</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span><span class="ident">x</span>.<span class="ident">split_whitespace</span>()).<span class="ident">collect</span>();
        <span class="comment">//We have now a vector of iterators</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">counter</span>:<span class="ident">i32</span><span class="op">=</span><span class="number">0</span>;
        <span class="kw">for</span> <span class="ident">it</span> <span class="kw">in</span> <span class="ident">v</span>{
            <span class="kw">let</span> <span class="ident">sub_vector</span>:<span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">it</span>.<span class="ident">collect</span>(); <span class="comment">//Convert the iterator into a vector of &amp;str </span>
            <span class="kw">let</span> (<span class="ident">range_text</span>,<span class="ident">character</span>,<span class="ident">context</span>)<span class="op">=</span>(<span class="ident">sub_vector</span>[<span class="number">0</span>],<span class="ident">sub_vector</span>[<span class="number">1</span>].<span class="ident">replace</span>(<span class="string">&quot;:&quot;</span>,<span class="string">&quot;&quot;</span>),<span class="ident">sub_vector</span>[<span class="number">2</span>]);
            <span class="kw">let</span> <span class="ident">range</span>:<span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span><span class="op">=</span><span class="ident">range_text</span>.<span class="ident">split</span>(<span class="string">&quot;-&quot;</span>).<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span><span class="ident">x</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>()).<span class="ident">collect</span>(); <span class="comment">//3-12 -&gt; [3,12]</span>
            <span class="kw">let</span> <span class="ident">occurences</span>:<span class="ident">i32</span><span class="op">=</span><span class="ident">context</span>.<span class="ident">matches</span>(<span class="kw-2">&amp;</span><span class="ident">character</span>).<span class="ident">count</span>().<span class="ident">try_into</span>().<span class="ident">unwrap</span>(); 
            <span class="comment">// creates an iterator by filtering out all the characters different from the specific character</span>
            <span class="comment">// count the elements of this iteratpr</span>
            <span class="comment">// attempt the conversion from usize into i32. Since it is an attempt, it returns Result</span>
            <span class="kw">if</span> (<span class="ident">occurences</span><span class="op">&gt;</span><span class="op">=</span><span class="ident">range</span>[<span class="number">0</span>]) <span class="op">&amp;&amp;</span> (<span class="ident">occurences</span><span class="op">&lt;</span><span class="op">=</span><span class="ident">range</span>[<span class="number">1</span>]) {
                <span class="ident">counter</span><span class="op">+</span><span class="op">=</span><span class="number">1</span>;
            }
        }
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">counter</span>);
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">part2</span>(<span class="ident">file_name</span>:<span class="kw-2">&amp;</span><span class="ident">str</span>)-&gt;<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>,<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>{
        <span class="comment">// Now range coontains the indexes (augmented by one) where we should see, at most once, the desired character</span>
        <span class="comment">// Recall that string indexing is not allowed in Rust because the loss of one-to-one correspondence between one character and one byte</span>
        <span class="comment">// We can build an iterator and access to the nth element of that iterator, indeed we assume to have just ascii characters</span>
        <span class="kw">let</span> <span class="ident">content</span>:<span class="ident">String</span> <span class="op">=</span> <span class="ident"><span class="kw">super</span>::fs::read_to_string</span>(<span class="ident">file_name</span>).<span class="ident">unwrap</span>();
        <span class="kw">let</span> <span class="ident">v</span>:<span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">=</span><span class="ident">content</span>.<span class="ident">lines</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span><span class="ident">x</span>.<span class="ident">split_whitespace</span>()).<span class="ident">collect</span>();
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">counter</span>:<span class="ident">i32</span><span class="op">=</span><span class="number">0</span>;
        <span class="kw">for</span> <span class="ident">value</span> <span class="kw">in</span> <span class="ident">v</span>{
            <span class="kw">let</span> <span class="ident">sub_vec</span>:<span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">value</span>.<span class="ident">collect</span>();
            <span class="kw">let</span> (<span class="ident">indexes</span>,<span class="ident">character</span>,<span class="ident">context</span>):(<span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,<span class="ident">String</span>,<span class="kw-2">&amp;</span><span class="ident">str</span>)<span class="op">=</span> (<span class="ident">sub_vec</span>[<span class="number">0</span>].<span class="ident">split</span>(<span class="string">&quot;-&quot;</span>).<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span><span class="ident">x</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>()).<span class="ident">collect</span>(),<span class="ident">sub_vec</span>[<span class="number">1</span>].<span class="ident">replace</span>(<span class="string">&quot;:&quot;</span>,<span class="string">&quot;&quot;</span>),<span class="ident">sub_vec</span>[<span class="number">2</span>]);
            <span class="kw">let</span> <span class="ident">string_iterator</span> <span class="op">=</span> <span class="ident">context</span>.<span class="ident">chars</span>(); <span class="comment">// Recall that .count() is the &quot;length&quot; of the iterator</span>
            <span class="kw">if</span> <span class="kw-2">&amp;</span><span class="ident">context</span>.<span class="ident">len</span>() <span class="op">!</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">string_iterator</span>.<span class="ident">clone</span>().<span class="ident">count</span>() {
                <span class="comment">//We&#39;re cloning the iterator because every iterator method requires the variablel to be mutable and we don&#39;t want that our iterator mutates</span>
                <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="string">&quot;Probably not ASCII type&quot;</span>);
            }
            <span class="kw">let</span> <span class="ident">first_match</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">string_iterator</span>.<span class="ident">clone</span>().<span class="ident">nth</span>((<span class="ident">indexes</span>[<span class="number">0</span>] <span class="op">-</span> <span class="number">1</span>).<span class="ident">try_into</span>().<span class="ident">unwrap</span>()).<span class="ident">unwrap</span>().<span class="ident">to_string</span>();
            <span class="kw">let</span> <span class="ident">second_match</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">string_iterator</span>.<span class="ident">clone</span>().<span class="ident">nth</span>((<span class="ident">indexes</span>[<span class="number">1</span>] <span class="op">-</span> <span class="number">1</span>).<span class="ident">try_into</span>().<span class="ident">unwrap</span>()).<span class="ident">unwrap</span>().<span class="ident">to_string</span>();
            <span class="comment">// We are unwrapping twice: </span>
            <span class="comment">// the first unwrap is in order to have a i32 to pass as argument of nth()</span>
            <span class="comment">// nth returns an option accessing to the nth position of the iterator (it might be out of bound), that&#39;s why it returns a Option</span>
            <span class="comment">// since in the good case nth() returns Some(char), we convett the char into a string via .to_string() (recall that it is equal to String::from(char))    </span>
            <span class="kw">if</span> (<span class="ident">first_match</span> <span class="op">==</span> <span class="kw-2">&amp;</span><span class="ident">character</span> <span class="op">&amp;&amp;</span> <span class="ident">second_match</span> <span class="op">!</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">character</span>) <span class="op">|</span><span class="op">|</span> (<span class="ident">first_match</span> <span class="op">!</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">character</span> <span class="op">&amp;&amp;</span> <span class="ident">second_match</span> <span class="op">==</span> <span class="kw-2">&amp;</span><span class="ident">character</span>) {
                <span class="ident">counter</span><span class="op">+</span><span class="op">=</span><span class="number">1</span>;
            }
        }
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">counter</span>); 
    }
}

<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">day3</span>{
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">part1</span>(<span class="ident">file_name</span>:<span class="kw-2">&amp;</span><span class="ident">str</span>, <span class="ident">plus_index</span>:<span class="kw-2">&amp;</span><span class="ident">i32</span>, <span class="ident">jump</span>:<span class="kw-2">&amp;</span><span class="ident">i32</span>)-&gt;<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>,<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>{
        <span class="kw">let</span> <span class="ident">content</span>:<span class="ident">String</span><span class="op">=</span><span class="ident"><span class="kw">super</span>::fs::read_to_string</span>(<span class="ident">file_name</span>).<span class="ident">unwrap</span>();
        <span class="kw">let</span> <span class="ident">v</span>:<span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span><span class="op">=</span><span class="ident">content</span>.<span class="ident">lines</span>().<span class="ident">collect</span>();
        <span class="comment">// slope of 3-right-1-down is equivalent to 3-right of the next element of the vector.</span>
        <span class="comment">//iterating over the vector, we need to check what&#39;s the character of the +3th position of the next vector</span>
        <span class="kw">let</span> <span class="ident">plus_index</span>:<span class="ident">usize</span> <span class="op">=</span> <span class="ident">TryInto</span>::<span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span><span class="ident">::try_into</span>(<span class="kw-2">*</span><span class="ident">plus_index</span>).<span class="ident">unwrap</span>();
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">next_iten_index</span>:<span class="ident">usize</span><span class="op">=</span><span class="number">0</span>;
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">next_index</span>:<span class="ident">usize</span><span class="op">=</span><span class="number">0</span>; <span class="comment">//since you&#39;re starting from the top left corner</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">counter</span>:<span class="ident">i32</span><span class="op">=</span><span class="number">0</span>;
        <span class="kw">for</span> <span class="ident">_el</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">v</span>{
            <span class="comment">//we stop if we are going to get an out of bound -&gt; recall that if the index is equal to the length of the vector you&#39;re out of bound</span>
            <span class="comment">//Recall that we&#39;re jumping from where we jumped in the previous cycle, we do not iterate naively over the vector</span>
            <span class="ident">next_iten_index</span><span class="op">+</span><span class="op">=</span><span class="ident">TryInto</span>::<span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span><span class="ident">::try_into</span>(<span class="kw-2">*</span><span class="ident">jump</span>).<span class="ident">unwrap</span>();
            <span class="kw">if</span> <span class="ident">next_iten_index</span><span class="op">&gt;</span><span class="op">=</span><span class="ident">v</span>.<span class="ident">len</span>(){
                <span class="kw">break</span>;
            }
            <span class="kw">let</span> <span class="ident">next_item</span> <span class="op">=</span> <span class="ident">v</span>[<span class="ident">next_iten_index</span>];
            <span class="ident">next_index</span><span class="op">+</span><span class="op">=</span><span class="ident">plus_index</span>; <span class="comment">//index of the character of the next_item</span>
            <span class="kw">if</span> <span class="ident">next_index</span><span class="op">&gt;</span><span class="op">=</span><span class="ident">next_item</span>.<span class="ident">len</span>(){ <span class="comment">//We capture the out of bound case (referred to next_item)</span>
                <span class="ident">next_index</span><span class="op">-</span><span class="op">=</span><span class="ident">next_item</span>.<span class="ident">len</span>(); <span class="comment">//the next_index will be the difference of before that makes us out of bound (recall that if next_index==next_item.len() -&gt; next_index will be 0)</span>
            }
            <span class="comment">//We check if we&#39;re allowed to index over the string thanks to the absence of ASCII characters&gt;1 byte</span>
            <span class="kw">if</span> <span class="ident">next_item</span>.<span class="ident">len</span>() <span class="op">!</span><span class="op">=</span> <span class="ident">next_item</span>.<span class="ident">chars</span>().<span class="ident">count</span>(){
                <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="string">&quot;Bad string&quot;</span>);
            }
            <span class="comment">//Recall that .nth() is valid with iterators, </span>
            <span class="kw">let</span> <span class="ident">jumped_element</span> <span class="op">=</span> <span class="ident">next_item</span>.<span class="ident">chars</span>().<span class="ident">nth</span>(<span class="ident">next_index</span>).<span class="ident">unwrap</span>();
            <span class="comment">//We&#39;ve taken the element: is it a square or a tree?</span>
            <span class="kw">if</span> <span class="ident">jumped_element</span><span class="op">==</span><span class="string">&#39;#&#39;</span>{ <span class="comment">//Recall that &quot;&quot; is for chars while &#39;&#39; is for &amp;str</span>
                <span class="ident">counter</span><span class="op">+</span><span class="op">=</span><span class="number">1</span>;
            }
        }
        <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>,<span class="ident">counter</span>);
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">counter</span>);
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">part2</span>(<span class="ident">file_name</span>:<span class="kw-2">&amp;</span><span class="ident">str</span>)-&gt;<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">u128</span>,<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>{
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cumulative_prod</span>:<span class="ident">u128</span> <span class="op">=</span><span class="number">1</span>;
        <span class="kw">for</span> <span class="ident">right</span> <span class="kw">in</span> (<span class="number">1</span>..<span class="op">=</span><span class="number">7</span>).<span class="ident">step_by</span>(<span class="number">2</span>){ <span class="comment">//We put equal in order to include the right extremum</span>
            <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>,<span class="ident">right</span>);
            <span class="kw">let</span> <span class="ident">ith_result</span>:<span class="ident">u128</span><span class="op">=</span><span class="ident">part1</span>(<span class="ident">file_name</span>,<span class="kw-2">&amp;</span><span class="ident">right</span>,<span class="kw-2">&amp;</span><span class="number">1</span>).<span class="ident">unwrap</span>().<span class="ident">try_into</span>().<span class="ident">unwrap</span>();
            <span class="ident">cumulative_prod</span><span class="kw-2">*</span><span class="op">=</span><span class="ident">ith_result</span>;
        }
        <span class="kw">let</span> <span class="ident">last_result</span>:<span class="ident">u128</span><span class="op">=</span><span class="ident">part1</span>(<span class="ident">file_name</span>,<span class="kw-2">&amp;</span><span class="number">1</span>,<span class="kw-2">&amp;</span><span class="number">2</span>).<span class="ident">unwrap</span>().<span class="ident">try_into</span>().<span class="ident">unwrap</span>();
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">last_result</span><span class="kw-2">*</span><span class="ident">cumulative_prod</span>);
    }
}

<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">day4</span>{

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">part1</span>(<span class="ident">file_name</span>:<span class="kw-2">&amp;</span><span class="ident">str</span>)-&gt;<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">usize</span>,<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>{
        <span class="kw">const</span> <span class="ident">MANDATORY_KEYS</span>:[<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span>;<span class="number">7</span>]<span class="op">=</span>[<span class="string">&quot;byr&quot;</span>, <span class="string">&quot;iyr&quot;</span>, <span class="string">&quot;eyr&quot;</span>, <span class="string">&quot;hgt&quot;</span>, <span class="string">&quot;hcl&quot;</span>, <span class="string">&quot;ecl&quot;</span>, <span class="string">&quot;pid&quot;</span>];
        <span class="comment">// let content = include_str!(&quot;../inputDay4.txt&quot;); //Fastest way to include a string: it works at compile time so we can&#39;t put a string variable, jsut a literal string (=hardcoding string)</span>
        <span class="kw">let</span> <span class="ident">content</span> <span class="op">=</span> <span class="ident"><span class="kw">super</span>::fs::read_to_string</span>(<span class="ident">file_name</span>).<span class="ident">unwrap</span>();
        <span class="kw">let</span> <span class="ident">final_documents</span> <span class="op">=</span> <span class="ident">content</span>
        .<span class="ident">split</span>(<span class="string">&quot;\r\n\r\n&quot;</span>) <span class="comment">//we split according to each blank line</span>
        .<span class="ident">map</span>(<span class="op">|</span><span class="ident">fields</span><span class="op">|</span> <span class="ident">fields</span>
            .<span class="ident">split_ascii_whitespace</span>() <span class="comment">//now we have a map of key:value</span>
            .<span class="ident">map</span>(<span class="op">|</span><span class="ident">field</span><span class="op">|</span><span class="ident">field</span>
                .<span class="ident">split</span>(<span class="string">&quot;:&quot;</span>) <span class="comment">//we divide key and value</span>
                .<span class="ident">next</span>() <span class="comment">// we take the first element (this would be equal to [0])</span>
                .<span class="ident">unwrap</span>() <span class="comment">//Since next() returns option</span>
            )
            .<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident"><span class="kw">super</span>::HashSet</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>() <span class="comment">//we arrange all the keys into a hashset</span>
        )
        .<span class="ident">filter</span>(<span class="op">|</span><span class="ident">passport</span><span class="op">|</span> <span class="comment">//return iterator whose elements satisifes the predicate</span>
            <span class="ident">MANDATORY_KEYS</span>
            .<span class="ident">iter</span>()
            .<span class="ident">all</span>( <span class="comment">// returns true if all the elements of the iterator satisfy the predicate </span>
                <span class="op">|</span><span class="ident">item</span><span class="op">|</span>
                <span class="ident">passport</span>.<span class="ident">contains</span>(<span class="ident">item</span>)
            )
        ).<span class="ident">count</span>();
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">final_documents</span>);
    }

    <span class="kw">fn</span> <span class="ident">validate_field</span>(<span class="ident">key</span>:<span class="kw-2">&amp;</span><span class="ident">str</span>, <span class="ident">value</span>:<span class="kw-2">&amp;</span><span class="ident">str</span>)-&gt;<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">bool</span>,<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>{ <span class="comment">//result returning boolean value or literal string</span>
        <span class="comment">//Each arm returns true</span>
        <span class="kw">let</span> <span class="ident">eye_color</span>:[<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span>;<span class="number">7</span>]<span class="op">=</span>[<span class="string">&quot;amb&quot;</span>,<span class="string">&quot;blu&quot;</span>,<span class="string">&quot;brn&quot;</span>,<span class="string">&quot;gry&quot;</span>,<span class="string">&quot;grn&quot;</span>,<span class="string">&quot;hzl&quot;</span>,<span class="string">&quot;oth&quot;</span>];
        <span class="kw">match</span> <span class="ident">key</span>{
            <span class="string">&quot;byr&quot;</span>=&gt;{
                <span class="kw">let</span> <span class="ident">val</span>:<span class="ident">i32</span> <span class="op">=</span> <span class="ident">value</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>();
                <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">val</span><span class="op">&gt;</span><span class="op">=</span><span class="number">1920</span> <span class="op">&amp;&amp;</span> <span class="ident">val</span><span class="op">&lt;</span><span class="op">=</span><span class="number">2002</span>);
            }, 
            <span class="string">&quot;iyr&quot;</span>=&gt;{
                <span class="kw">let</span> <span class="ident">val</span>:<span class="ident">i32</span> <span class="op">=</span> <span class="ident">value</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>();
                <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">val</span><span class="op">&gt;</span><span class="op">=</span><span class="number">2010</span> <span class="op">&amp;&amp;</span> <span class="ident">val</span><span class="op">&lt;</span><span class="op">=</span><span class="number">2020</span>);
            }, 
            <span class="string">&quot;eyr&quot;</span>=&gt;{
                <span class="kw">let</span> <span class="ident">val</span>:<span class="ident">i32</span> <span class="op">=</span> <span class="ident">value</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>();
                <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">val</span><span class="op">&gt;</span><span class="op">=</span><span class="number">2020</span> <span class="op">&amp;&amp;</span> <span class="ident">val</span><span class="op">&lt;</span><span class="op">=</span><span class="number">2030</span>);
            }, 
            <span class="string">&quot;hgt&quot;</span>=&gt;{
                <span class="kw">if</span> <span class="ident">value</span>.<span class="ident">contains</span>(<span class="string">&quot;cm&quot;</span>){
                    <span class="kw">let</span> <span class="ident">val</span>:<span class="ident">usize</span> <span class="op">=</span> <span class="ident">value</span>.<span class="ident">replace</span>(<span class="string">&quot;cm&quot;</span>,<span class="string">&quot;&quot;</span>).<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>().<span class="ident">unwrap</span>().<span class="ident">try_into</span>().<span class="ident">unwrap</span>(); <span class="comment">//we use usize because wrapping_sub is a usize method</span>
                    <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">val</span>.<span class="ident">wrapping_sub</span>(<span class="number">150</span>)<span class="op">&lt;</span><span class="op">=</span><span class="number">43</span>); <span class="comment">//we convert 150&lt;val&lt;193 into val-150&lt;193-150:</span>
                }
                <span class="kw">else</span> <span class="kw">if</span> <span class="ident">value</span>.<span class="ident">contains</span>(<span class="string">&quot;in&quot;</span>){
                    <span class="kw">let</span> <span class="ident">val</span>:<span class="ident">usize</span> <span class="op">=</span> <span class="ident">value</span>.<span class="ident">replace</span>(<span class="string">&quot;in&quot;</span>,<span class="string">&quot;&quot;</span>).<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>().<span class="ident">unwrap</span>().<span class="ident">try_into</span>().<span class="ident">unwrap</span>(); <span class="comment">//we use usize because wrapping_sub is a usize method</span>
                    <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">val</span>.<span class="ident">wrapping_sub</span>(<span class="number">59</span>)<span class="op">&lt;</span><span class="op">=</span><span class="number">17</span>); 
                }
                <span class="kw">else</span>{
                    <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="bool-val">false</span>);
                }
            }
            <span class="string">&quot;hcl&quot;</span>=&gt;<span class="prelude-val">Ok</span>(<span class="ident">value</span>.<span class="ident">len</span>()<span class="op">==</span><span class="number">7</span>), 
            <span class="string">&quot;ecl&quot;</span>=&gt;<span class="prelude-val">Ok</span>(<span class="ident">eye_color</span>.<span class="ident">iter</span>().<span class="ident">any</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span><span class="ident">x</span><span class="op">==</span><span class="kw-2">&amp;</span><span class="ident">value</span>)), <span class="comment">//iterating over eye_color, at least one occurrence match with the</span>
            <span class="string">&quot;pid&quot;</span>=&gt;<span class="prelude-val">Ok</span>(<span class="ident">value</span>.<span class="ident">len</span>()<span class="op">==</span><span class="number">9</span>),
            <span class="string">&quot;cid&quot;</span>=&gt;<span class="prelude-val">Ok</span>(<span class="bool-val">true</span>), <span class="comment">//cid can be whatever, we don&#39;t care</span>
            <span class="kw">_</span>=&gt;<span class="prelude-val">Err</span>(<span class="string">&quot;Unrecognizable key&quot;</span>)
        }
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">part2</span>(<span class="ident">file_name</span>:<span class="kw-2">&amp;</span><span class="ident">str</span>)-&gt;<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">usize</span>,<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>{
        <span class="kw">let</span> <span class="ident">mandatory_keys</span>:[<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span>; <span class="number">7</span>] <span class="op">=</span> [<span class="string">&quot;byr&quot;</span>, <span class="string">&quot;iyr&quot;</span>, <span class="string">&quot;eyr&quot;</span>, <span class="string">&quot;hgt&quot;</span>, <span class="string">&quot;hcl&quot;</span>, <span class="string">&quot;ecl&quot;</span>, <span class="string">&quot;pid&quot;</span>];
        <span class="kw">let</span> <span class="ident">content</span> <span class="op">=</span> <span class="ident"><span class="kw">super</span>::fs::read_to_string</span>(<span class="ident">file_name</span>).<span class="ident">unwrap</span>();
        <span class="kw">let</span> <span class="ident">final_documents</span> <span class="op">=</span> <span class="ident">content</span>
        .<span class="ident">split</span>(<span class="string">&quot;\r\n\r\n&quot;</span>)
        .<span class="ident">map</span>(<span class="op">|</span><span class="ident">fields</span><span class="op">|</span><span class="ident">fields</span> <span class="comment">//we iterate over blank spaces</span>
            .<span class="ident">split_ascii_whitespace</span>()
            .<span class="ident">map</span>(<span class="op">|</span><span class="ident">field</span><span class="op">|</span><span class="ident">field</span>
                .<span class="ident">split_once</span>(<span class="string">&quot;:&quot;</span>) <span class="comment">//if the character is present more than once, it splits just the first occurence</span>
                .<span class="ident">unwrap</span>()
            )
            .<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident"><span class="kw">super</span>::HashMap</span><span class="op">&lt;</span><span class="kw">_</span>,<span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>() <span class="comment">//we split keys and values and we wrap them into a hasmap (not a hashset)</span>
        )
        .<span class="ident">filter</span>(<span class="op">|</span><span class="ident">passport</span><span class="op">|</span> <span class="comment">//recall that we&#39;re iterating over hashmap</span>
            <span class="ident">mandatory_keys</span>.<span class="ident">iter</span>().<span class="ident">all</span>(<span class="op">|</span><span class="ident">item</span><span class="op">|</span> <span class="comment">//we&#39;re converting array -&gt; iterator -&gt; we iterate over each element making sure that the predicate returns true for each element</span>
                <span class="ident">passport</span>.<span class="ident">contains_key</span>(<span class="ident">item</span>) <span class="comment">//we check that the mandatory keys are all present</span>
            )
        )<span class="comment">//so far we checked the valid passports like part1</span>
        .<span class="ident">filter</span>(<span class="op">|</span><span class="ident">passport</span><span class="op">|</span>           
            <span class="comment">//Now we check the integrity of each field: we use all() and a match structure</span>
            <span class="ident">passport</span>.<span class="ident">iter</span>().<span class="ident">all</span>(<span class="op">|</span>(<span class="ident">key</span>,<span class="ident">value</span>)<span class="op">|</span> <span class="comment">//recall that we&#39;re iterating over the hashmap, so we use the tuple (not two separated variables)</span>
                <span class="ident">validate_field</span>(<span class="ident">key</span>,<span class="ident">value</span>).<span class="ident">unwrap</span>()
            )

        ).<span class="ident">count</span>();
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">final_documents</span>);
    }
}

<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">day5</span>{
    <span class="comment">// #[derive(Debug)]</span>
    <span class="comment">// struct Seat{</span>
    <span class="comment">//     row:i32,</span>
    <span class="comment">//     col:i32,</span>
    <span class="comment">//     id:i32</span>
    <span class="comment">// }</span>

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">part1</span>(<span class="ident">file_name</span>:<span class="kw-2">&amp;</span><span class="ident">str</span>)-&gt;<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>,<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>{
        <span class="kw">let</span> <span class="ident">content</span> <span class="op">=</span> <span class="ident"><span class="kw">super</span>::fs::read_to_string</span>(<span class="ident">file_name</span>).<span class="ident">unwrap</span>();
        <span class="kw">let</span> <span class="ident">max_seat_id</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">content</span>.<span class="ident">lines</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">b_p</span><span class="op">|</span> {
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cap_row</span> <span class="op">=</span> <span class="number">127</span>;
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">start_row</span><span class="op">=</span><span class="number">0</span>;
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cap_col</span> <span class="op">=</span> <span class="number">7</span>;
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">start_col</span><span class="op">=</span><span class="number">0</span>;
            <span class="kw">let</span> <span class="ident">charz</span> <span class="op">=</span> <span class="ident">b_p</span>.<span class="ident">chars</span>();
            <span class="kw">for</span> <span class="ident">c</span> <span class="kw">in</span> <span class="ident">charz</span>{
                <span class="kw">match</span> <span class="ident">c</span>{
                    <span class="comment">//We take the median value</span>
                    <span class="string">&#39;B&#39;</span>=&gt;{<span class="ident">start_row</span><span class="op">=</span>(<span class="ident">start_row</span><span class="op">+</span><span class="ident">cap_row</span><span class="op">+</span><span class="number">1</span>)<span class="op">&gt;</span><span class="op">&gt;</span><span class="number">1</span>},
                    <span class="string">&#39;F&#39;</span>=&gt;{<span class="ident">cap_row</span><span class="op">=</span>(<span class="ident">start_row</span><span class="op">+</span><span class="ident">cap_row</span><span class="op">+</span><span class="number">1</span>)<span class="op">&gt;</span><span class="op">&gt;</span><span class="number">1</span>},
                    <span class="string">&#39;R&#39;</span>=&gt;{<span class="ident">start_col</span><span class="op">=</span>(<span class="ident">start_col</span><span class="op">+</span><span class="ident">cap_col</span><span class="op">+</span><span class="number">1</span>)<span class="op">&gt;</span><span class="op">&gt;</span><span class="number">1</span>},
                    <span class="string">&#39;L&#39;</span>=&gt;{<span class="ident">cap_col</span><span class="op">=</span>(<span class="ident">start_col</span><span class="op">+</span><span class="ident">cap_col</span><span class="op">+</span><span class="number">1</span>)<span class="op">&gt;</span><span class="op">&gt;</span><span class="number">1</span>},
                    <span class="kw">_</span>=&gt;()
                }
            }
            <span class="kw">let</span> <span class="ident">id</span> <span class="op">=</span> (<span class="ident">cap_row</span>.<span class="ident">min</span>(<span class="ident">start_row</span>) <span class="op">&lt;</span><span class="op">&lt;</span> <span class="number">3</span>) <span class="op">+</span> <span class="ident">cap_col</span>.<span class="ident">min</span>(<span class="ident">start_col</span>);
            <span class="comment">// let _seat = Seat{</span>
            <span class="comment">//     row:cap_row.min(start_row),</span>
            <span class="comment">//     col:cap_col.min(start_col),</span>
            <span class="comment">//     id</span>
            <span class="comment">// };</span>
            <span class="kw">return</span> <span class="ident">id</span>;
        }).<span class="ident">max</span>().<span class="ident">unwrap</span>();
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="kw-2">*</span><span class="ident">max_seat_id</span>);
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">part2</span>(<span class="ident">file_name</span>:<span class="kw-2">&amp;</span><span class="ident">str</span>)-&gt;<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>,<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>{
        <span class="comment">//We order seat ids and we check wheteher ther is a jump in the list</span>
        <span class="kw">let</span> <span class="ident">content</span> <span class="op">=</span> <span class="ident"><span class="kw">super</span>::fs::read_to_string</span>(<span class="ident">file_name</span>).<span class="ident">unwrap</span>();
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">seat_ids</span><span class="op">=</span> <span class="ident">content</span>.<span class="ident">lines</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">b_p</span><span class="op">|</span> {
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cap_row</span> <span class="op">=</span> <span class="number">127</span>;
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">start_row</span><span class="op">=</span><span class="number">0</span>;
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cap_col</span> <span class="op">=</span> <span class="number">7</span>;
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">start_col</span><span class="op">=</span><span class="number">0</span>;
            <span class="kw">let</span> <span class="ident">charz</span> <span class="op">=</span> <span class="ident">b_p</span>.<span class="ident">chars</span>();
            <span class="kw">for</span> <span class="ident">c</span> <span class="kw">in</span> <span class="ident">charz</span>{
                <span class="kw">match</span> <span class="ident">c</span>{
                    <span class="comment">//We take the median value</span>
                    <span class="string">&#39;B&#39;</span>=&gt;{<span class="ident">start_row</span><span class="op">=</span>(<span class="ident">start_row</span><span class="op">+</span><span class="ident">cap_row</span><span class="op">+</span><span class="number">1</span>)<span class="op">&gt;</span><span class="op">&gt;</span><span class="number">1</span>},
                    <span class="string">&#39;F&#39;</span>=&gt;{<span class="ident">cap_row</span><span class="op">=</span>(<span class="ident">start_row</span><span class="op">+</span><span class="ident">cap_row</span><span class="op">+</span><span class="number">1</span>)<span class="op">&gt;</span><span class="op">&gt;</span><span class="number">1</span>},
                    <span class="string">&#39;R&#39;</span>=&gt;{<span class="ident">start_col</span><span class="op">=</span>(<span class="ident">start_col</span><span class="op">+</span><span class="ident">cap_col</span><span class="op">+</span><span class="number">1</span>)<span class="op">&gt;</span><span class="op">&gt;</span><span class="number">1</span>},
                    <span class="string">&#39;L&#39;</span>=&gt;{<span class="ident">cap_col</span><span class="op">=</span>(<span class="ident">start_col</span><span class="op">+</span><span class="ident">cap_col</span><span class="op">+</span><span class="number">1</span>)<span class="op">&gt;</span><span class="op">&gt;</span><span class="number">1</span>},
                    <span class="kw">_</span>=&gt;()
                }
            }
            <span class="kw">let</span> <span class="ident">id</span> <span class="op">=</span> (<span class="ident">cap_row</span>.<span class="ident">min</span>(<span class="ident">start_row</span>) <span class="op">&lt;</span><span class="op">&lt;</span> <span class="number">3</span>) <span class="op">+</span> <span class="ident">cap_col</span>.<span class="ident">min</span>(<span class="ident">start_col</span>);
            <span class="kw">return</span>  <span class="ident">id</span>;
        }).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>();
        <span class="comment">//Recall that sort_by doesn&#39;t return anything and the self argument is taken as mutable;</span>
        <span class="ident">seat_ids</span>.<span class="ident">sort_by</span>(<span class="op">|</span><span class="ident">a</span>,<span class="ident">b</span><span class="op">|</span><span class="ident">a</span>.<span class="ident">cmp</span>(<span class="kw-2">&amp;</span><span class="ident">b</span>));
        <span class="comment">//Now the array seat_ids is sorted</span>
        <span class="kw">for</span> (<span class="ident">i</span>,<span class="ident">elem</span>) <span class="kw">in</span> <span class="ident">seat_ids</span>.<span class="ident">iter</span>().<span class="ident">enumerate</span>(){
            <span class="kw">if</span> <span class="ident">i</span><span class="op">==</span><span class="number">0</span>{
                <span class="kw">continue</span>
            }
            <span class="kw">if</span> <span class="kw-2">*</span><span class="ident">elem</span> <span class="op">!</span><span class="op">=</span> <span class="ident">seat_ids</span>[<span class="ident">i</span><span class="op">-</span><span class="number">1</span>]<span class="op">+</span><span class="number">1</span> {
                <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="kw-2">*</span><span class="ident">elem</span><span class="op">-</span><span class="number">1</span>); <span class="comment">//586...588</span>
            }
        }
        <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="string">&quot;Seat not found!&quot;</span>);
    }
}

<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">day6</span>{

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">part1</span>(<span class="ident">file_name</span>:<span class="kw-2">&amp;</span><span class="ident">str</span>)-&gt;<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>,<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>{
        <span class="kw">let</span> <span class="ident">content</span> <span class="op">=</span> <span class="ident"><span class="kw">super</span>::fs::read_to_string</span>(<span class="ident">file_name</span>).<span class="ident">unwrap</span>();
        <span class="kw">let</span> <span class="ident">total_num_quest</span>:<span class="ident">i32</span> <span class="op">=</span> <span class="ident">content</span>
        .<span class="ident">split</span>(<span class="string">&quot;\r\n\r\n&quot;</span>)
        .<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span>{
            <span class="comment">// Recall that hashset is a collection that eliminates duplicates -&gt; we create a hashet from chars()</span>
            <span class="kw">let</span> <span class="ident">answers</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">replace</span>(<span class="string">&quot;\r\n&quot;</span>,<span class="string">&quot;&quot;</span>).<span class="ident">chars</span>().<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident"><span class="kw">super</span>::HashSet</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>().<span class="ident">iter</span>().<span class="ident">count</span>();
            <span class="kw">return</span> <span class="ident">TryInto</span>::<span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span><span class="ident">::try_into</span>(<span class="ident">answers</span>).<span class="ident">unwrap</span>();
        }).<span class="ident">sum</span>::<span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span>().<span class="ident">try_into</span>().<span class="ident">unwrap</span>();
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">total_num_quest</span>);
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">part2</span>(<span class="ident">file_name</span>:<span class="kw-2">&amp;</span><span class="ident">str</span>)-&gt;<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">usize</span>,<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>{
        <span class="comment">//Now it&#39;s about counting the number of words that are present in each line of a given block -&gt; this is equivalent to say how many question have been answered with &quot;yes&quot; by each member of a given group</span>
        <span class="kw">let</span> <span class="ident">content</span> <span class="op">=</span> <span class="ident"><span class="kw">super</span>::fs::read_to_string</span>(<span class="ident">file_name</span>).<span class="ident">unwrap</span>();
        <span class="kw">let</span> <span class="ident">total_num_quest</span>:<span class="ident">usize</span> <span class="op">=</span> <span class="ident">content</span>
        .<span class="ident">split</span>(<span class="string">&quot;\r\n\r\n&quot;</span>) <span class="comment">//We create an array of groups;</span>
        .<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span>{
            <span class="kw">let</span> <span class="ident">raw_answers</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split_ascii_whitespace</span>(); <span class="comment">//we take each line of a given group</span>
            <span class="kw">let</span> <span class="ident">people</span> <span class="op">=</span> <span class="ident">raw_answers</span>.<span class="ident">count</span>(); <span class="comment">//we count the number of lines</span>
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">big_counter</span>:<span class="ident"><span class="kw">super</span>::HashMap</span><span class="op">&lt;</span><span class="ident">char</span>,<span class="ident">usize</span><span class="op">&gt;</span><span class="op">=</span><span class="ident"><span class="kw">super</span>::HashMap::new</span>(); <span class="comment">//we init a table for counting same characters in a given group (not line!)</span>
            <span class="kw">for</span> <span class="ident">c</span> <span class="kw">in</span> <span class="ident">x</span>.<span class="ident">replace</span>(<span class="string">&quot;\r\n&quot;</span>,<span class="string">&quot;&quot;</span>).<span class="ident">chars</span>(){ <span class="comment">//we avoid to count ascii whitespaces</span>
                <span class="kw">let</span> <span class="ident">particular_counter</span> <span class="op">=</span> <span class="ident">big_counter</span>.<span class="ident">entry</span>(<span class="ident">c</span>).<span class="ident">or_insert</span>(<span class="number">0</span>); <span class="comment">//we take the value associated to the character in the mapping, if nothing is present we initialize it with zero</span>
                <span class="comment">//By de-referencing the particular counter, we are able to update that value</span>
                 <span class="kw-2">*</span><span class="ident">particular_counter</span><span class="op">+</span><span class="op">=</span><span class="number">1</span>;
            }
            <span class="comment">//Now we filter out all the keys (=questions) whose value is different from the numebr of ppl (=number of lines)</span>
            <span class="kw">return</span> <span class="ident">big_counter</span>.<span class="ident">values</span>().<span class="ident">filter</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span><span class="kw-2">*</span><span class="ident">x</span><span class="op">==</span><span class="kw-2">&amp;</span><span class="ident">people</span>).<span class="ident">count</span>();
        })
        <span class="comment">//Each item in this array is the number of same questions answered affermatively by each memeber of the group, now we sum them </span>
        .<span class="ident">sum</span>();
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">total_num_quest</span>);
        <span class="comment">// return total_num_quest;</span>
    }

}

<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">day7</span>{
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">part1</span>(<span class="ident">file_name</span>:<span class="kw-2">&amp;</span><span class="ident">str</span>)-&gt;<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">usize</span>,<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>{
        <span class="comment">// One strategy might split the string when &quot;contain&quot; occur</span>
        <span class="comment">// The tricky thing is that you must map also all the bags that can contain the shiny gold bag, because if such bags can be contained by other bags, then such bags can contain the shiny gold bag</span>
        <span class="kw">let</span> <span class="ident">content</span> <span class="op">=</span> <span class="ident"><span class="kw">super</span>::fs::read_to_string</span>(<span class="ident">file_name</span>).<span class="ident">unwrap</span>();
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rules_count</span>:<span class="ident"><span class="kw">super</span>::HashSet</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">content</span>.<span class="ident">lines</span>().<span class="ident">filter</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span><span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&quot;contain&quot;</span>).<span class="ident">nth</span>(<span class="number">1</span>).<span class="ident">unwrap</span>().<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="string">&quot;shiny gold bags&quot;</span>)).<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span>{
            <span class="kw">let</span> <span class="ident">nth_bag</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&quot;contain&quot;</span>).<span class="ident">nth</span>(<span class="number">0</span>).<span class="ident">unwrap</span>().<span class="ident">trim</span>();
            <span class="kw">return</span> <span class="ident">nth_bag</span>;
        }).<span class="ident">collect</span>();
        <span class="kw">loop</span> { <span class="comment">//equivalent of while true</span>
            <span class="kw">let</span> <span class="ident">new_list</span> <span class="op">=</span> <span class="ident">content</span>.<span class="ident">lines</span>().<span class="ident">filter</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span><span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&quot;contain&quot;</span>).<span class="ident">nth</span>(<span class="number">1</span>).<span class="ident">unwrap</span>().<span class="ident">contains</span>(<span class="ident">rules_count</span>.<span class="ident">iter</span>().<span class="ident">next</span>().<span class="ident">unwrap</span>())).<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span><span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&quot;contain&quot;</span>).<span class="ident">nth</span>(<span class="number">0</span>).<span class="ident">unwrap</span>().<span class="ident">trim</span>());
            <span class="kw">if</span> <span class="ident">new_list</span>.<span class="ident">clone</span>().<span class="ident">count</span>()<span class="op">==</span><span class="number">0</span>{
                <span class="kw">break</span>   
            }
            <span class="ident">new_list</span>.<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span>{<span class="ident">rules_count</span>.<span class="ident">insert</span>(<span class="ident">x</span>);}); <span class="comment">//we put the curly in order to convert the predicate into a function</span>
        }
        <span class="comment">// Now we iterate over this array, taking the same instruction</span>
        <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">rules_count</span>);
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">rules_count</span>.<span class="ident">iter</span>().<span class="ident">count</span>());
    }

    <span class="comment">// pub fn part2(file_name:&amp;str)-&gt;Result&lt;usize,&amp;&#39;static str&gt;{</span>
        
    <span class="comment">// }</span>
}</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="advent_of_code" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.62.1 (e092d0b6b 2022-07-16)" ></div>
</body></html>